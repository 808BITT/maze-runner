{"ast":null,"code":"/**\r\n * Game Renderer Utilities\r\n * \r\n * Contains functions for rendering the maze, player, and fog of war on canvas\r\n */\n\n// Cell size in pixels\nconst CELL_SIZE = 20;\n\n/**\r\n * Render the maze grid on the canvas\r\n * \r\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\r\n * @param {object} maze - Maze data object\r\n */\nexport function renderMaze(ctx, maze) {\n  const {\n    grid,\n    width,\n    height\n  } = maze;\n\n  // Set canvas dimensions\n  ctx.canvas.width = width * CELL_SIZE;\n  ctx.canvas.height = height * CELL_SIZE;\n\n  // Clear canvas\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  // Draw maze cells\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const cell = grid[y][x];\n      const xPos = x * CELL_SIZE;\n      const yPos = y * CELL_SIZE;\n\n      // Draw cell based on type\n      switch (cell) {\n        case 0:\n          // Path\n          ctx.fillStyle = '#444444';\n          break;\n        case 1:\n          // Wall\n          ctx.fillStyle = '#111111';\n          break;\n        case 2:\n          // Start\n          ctx.fillStyle = '#4a74e8';\n          break;\n        case 3:\n          // Exit\n          ctx.fillStyle = '#8149e8';\n          break;\n        default:\n          ctx.fillStyle = '#333333';\n      }\n      ctx.fillRect(xPos, yPos, CELL_SIZE, CELL_SIZE);\n\n      // Add grid lines\n      ctx.strokeStyle = '#222222';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(xPos, yPos, CELL_SIZE, CELL_SIZE);\n    }\n  }\n}\n\n/**\r\n * Render fog of war overlay on canvas\r\n * \r\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\r\n * @param {Array} fogGrid - 2D array representing fog of war (1=fogged, 0=visible)\r\n */\nexport function renderFogOfWar(ctx, fogGrid) {\n  const height = fogGrid.length;\n  const width = fogGrid[0].length;\n\n  // Set canvas dimensions\n  ctx.canvas.width = width * CELL_SIZE;\n  ctx.canvas.height = height * CELL_SIZE;\n\n  // Clear canvas\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  // Draw fog\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      if (fogGrid[y][x] === 1) {\n        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);\n      }\n    }\n  }\n}\n\n/**\r\n * Render player character on canvas\r\n * \r\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\r\n * @param {object} position - Player position {x, y}\r\n * @param {object} maze - Maze data object (for dimensions)\r\n */\nexport function renderPlayer(ctx, position, maze) {\n  const {\n    x,\n    y\n  } = position;\n\n  // Calculate center position of the cell\n  const centerX = x * CELL_SIZE + CELL_SIZE / 2;\n  const centerY = y * CELL_SIZE + CELL_SIZE / 2;\n  const radius = CELL_SIZE * 0.35;\n\n  // Draw player circle\n  ctx.beginPath();\n  ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n  ctx.fillStyle = '#e84a74';\n  ctx.fill();\n\n  // Add outline\n  ctx.strokeStyle = 'white';\n  ctx.lineWidth = 2;\n  ctx.stroke();\n\n  // Add shadow\n  ctx.shadowColor = '#e84a74';\n  ctx.shadowBlur = 10;\n  ctx.fill();\n  ctx.shadowBlur = 0;\n}\n\n/**\r\n * Calculate viewport dimensions and offsets for camera follow\r\n * Note: For future implementation of camera that follows player\r\n * \r\n * @param {object} position - Player position\r\n * @param {number} canvasWidth - Canvas width in pixels\r\n * @param {number} canvasHeight - Canvas height in pixels\r\n * @param {object} maze - Maze data object\r\n * @returns {object} Viewport info {offsetX, offsetY, visibleWidth, visibleHeight}\r\n */\nexport function calculateViewport(position, canvasWidth, canvasHeight, maze) {\n  const mazeWidthPx = maze.width * CELL_SIZE;\n  const mazeHeightPx = maze.height * CELL_SIZE;\n\n  // Center viewport on player\n  let offsetX = position.x * CELL_SIZE - canvasWidth / 2;\n  let offsetY = position.y * CELL_SIZE - canvasHeight / 2;\n\n  // Bound offsets to keep viewport within maze\n  offsetX = Math.max(0, Math.min(offsetX, mazeWidthPx - canvasWidth));\n  offsetY = Math.max(0, Math.min(offsetY, mazeHeightPx - canvasHeight));\n  return {\n    offsetX,\n    offsetY,\n    visibleWidth: Math.min(canvasWidth, mazeWidthPx),\n    visibleHeight: Math.min(canvasHeight, mazeHeightPx)\n  };\n}","map":{"version":3,"names":["CELL_SIZE","renderMaze","ctx","maze","grid","width","height","canvas","clearRect","y","x","cell","xPos","yPos","fillStyle","fillRect","strokeStyle","lineWidth","strokeRect","renderFogOfWar","fogGrid","length","renderPlayer","position","centerX","centerY","radius","beginPath","arc","Math","PI","fill","stroke","shadowColor","shadowBlur","calculateViewport","canvasWidth","canvasHeight","mazeWidthPx","mazeHeightPx","offsetX","offsetY","max","min","visibleWidth","visibleHeight"],"sources":["C:/Users/mbobbitt/Hyde/maze-runner/client/src/utils/gameRenderer.js"],"sourcesContent":["/**\r\n * Game Renderer Utilities\r\n * \r\n * Contains functions for rendering the maze, player, and fog of war on canvas\r\n */\r\n\r\n// Cell size in pixels\r\nconst CELL_SIZE = 20;\r\n\r\n/**\r\n * Render the maze grid on the canvas\r\n * \r\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\r\n * @param {object} maze - Maze data object\r\n */\r\nexport function renderMaze(ctx, maze) {\r\n    const { grid, width, height } = maze;\r\n\r\n    // Set canvas dimensions\r\n    ctx.canvas.width = width * CELL_SIZE;\r\n    ctx.canvas.height = height * CELL_SIZE;\r\n\r\n    // Clear canvas\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    // Draw maze cells\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            const cell = grid[y][x];\r\n            const xPos = x * CELL_SIZE;\r\n            const yPos = y * CELL_SIZE;\r\n\r\n            // Draw cell based on type\r\n            switch (cell) {\r\n                case 0: // Path\r\n                    ctx.fillStyle = '#444444';\r\n                    break;\r\n                case 1: // Wall\r\n                    ctx.fillStyle = '#111111';\r\n                    break;\r\n                case 2: // Start\r\n                    ctx.fillStyle = '#4a74e8';\r\n                    break;\r\n                case 3: // Exit\r\n                    ctx.fillStyle = '#8149e8';\r\n                    break;\r\n                default:\r\n                    ctx.fillStyle = '#333333';\r\n            }\r\n\r\n            ctx.fillRect(xPos, yPos, CELL_SIZE, CELL_SIZE);\r\n\r\n            // Add grid lines\r\n            ctx.strokeStyle = '#222222';\r\n            ctx.lineWidth = 1;\r\n            ctx.strokeRect(xPos, yPos, CELL_SIZE, CELL_SIZE);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Render fog of war overlay on canvas\r\n * \r\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\r\n * @param {Array} fogGrid - 2D array representing fog of war (1=fogged, 0=visible)\r\n */\r\nexport function renderFogOfWar(ctx, fogGrid) {\r\n    const height = fogGrid.length;\r\n    const width = fogGrid[0].length;\r\n\r\n    // Set canvas dimensions\r\n    ctx.canvas.width = width * CELL_SIZE;\r\n    ctx.canvas.height = height * CELL_SIZE;\r\n\r\n    // Clear canvas\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    // Draw fog\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            if (fogGrid[y][x] === 1) {\r\n                ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Render player character on canvas\r\n * \r\n * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\r\n * @param {object} position - Player position {x, y}\r\n * @param {object} maze - Maze data object (for dimensions)\r\n */\r\nexport function renderPlayer(ctx, position, maze) {\r\n    const { x, y } = position;\r\n\r\n    // Calculate center position of the cell\r\n    const centerX = (x * CELL_SIZE) + (CELL_SIZE / 2);\r\n    const centerY = (y * CELL_SIZE) + (CELL_SIZE / 2);\r\n    const radius = CELL_SIZE * 0.35;\r\n\r\n    // Draw player circle\r\n    ctx.beginPath();\r\n    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\r\n    ctx.fillStyle = '#e84a74';\r\n    ctx.fill();\r\n\r\n    // Add outline\r\n    ctx.strokeStyle = 'white';\r\n    ctx.lineWidth = 2;\r\n    ctx.stroke();\r\n\r\n    // Add shadow\r\n    ctx.shadowColor = '#e84a74';\r\n    ctx.shadowBlur = 10;\r\n    ctx.fill();\r\n    ctx.shadowBlur = 0;\r\n}\r\n\r\n/**\r\n * Calculate viewport dimensions and offsets for camera follow\r\n * Note: For future implementation of camera that follows player\r\n * \r\n * @param {object} position - Player position\r\n * @param {number} canvasWidth - Canvas width in pixels\r\n * @param {number} canvasHeight - Canvas height in pixels\r\n * @param {object} maze - Maze data object\r\n * @returns {object} Viewport info {offsetX, offsetY, visibleWidth, visibleHeight}\r\n */\r\nexport function calculateViewport(position, canvasWidth, canvasHeight, maze) {\r\n    const mazeWidthPx = maze.width * CELL_SIZE;\r\n    const mazeHeightPx = maze.height * CELL_SIZE;\r\n\r\n    // Center viewport on player\r\n    let offsetX = (position.x * CELL_SIZE) - (canvasWidth / 2);\r\n    let offsetY = (position.y * CELL_SIZE) - (canvasHeight / 2);\r\n\r\n    // Bound offsets to keep viewport within maze\r\n    offsetX = Math.max(0, Math.min(offsetX, mazeWidthPx - canvasWidth));\r\n    offsetY = Math.max(0, Math.min(offsetY, mazeHeightPx - canvasHeight));\r\n\r\n    return {\r\n        offsetX,\r\n        offsetY,\r\n        visibleWidth: Math.min(canvasWidth, mazeWidthPx),\r\n        visibleHeight: Math.min(canvasHeight, mazeHeightPx)\r\n    };\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}